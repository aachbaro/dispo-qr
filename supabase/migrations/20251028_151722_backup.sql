

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."facture_status" AS ENUM (
    'pending_payment',
    'paid',
    'canceled'
);


ALTER TYPE "public"."facture_status" OWNER TO "postgres";


CREATE TYPE "public"."mission_mode" AS ENUM (
    'freelance',
    'salarié'
);


ALTER TYPE "public"."mission_mode" OWNER TO "postgres";


CREATE TYPE "public"."mission_status" AS ENUM (
    'proposed',
    'validated',
    'pending_payment',
    'paid',
    'completed',
    'refused',
    'realized'
);


ALTER TYPE "public"."mission_status" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."unavailabilities_validate"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  IF NEW.recurrence_type = 'weekly' AND NEW.weekday IS NULL THEN
    RAISE EXCEPTION 'weekday must be set for weekly recurrence';
  END IF;

  IF NEW.recurrence_type <> 'weekly' AND NEW.weekday IS NOT NULL THEN
    RAISE EXCEPTION 'weekday must be null unless recurrence_type = weekly';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."unavailabilities_validate"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."client_contacts" (
    "id" bigint NOT NULL,
    "client_id" "uuid" NOT NULL,
    "entreprise_id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."client_contacts" OWNER TO "postgres";


ALTER TABLE "public"."client_contacts" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."client_contacts_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."clients" (
    "id" "uuid" NOT NULL,
    "role" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."clients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."entreprise" (
    "id" bigint NOT NULL,
    "user_id" "uuid",
    "nom" "text" NOT NULL,
    "prenom" "text" NOT NULL,
    "adresse_ligne1" "text" NOT NULL,
    "email" "text" NOT NULL,
    "telephone" "text",
    "siret" "text" NOT NULL,
    "statut_juridique" "text" DEFAULT 'micro-entreprise'::"text" NOT NULL,
    "tva_intracom" "text",
    "mention_tva" "text" DEFAULT 'TVA non applicable, art. 293 B du CGI'::"text" NOT NULL,
    "iban" "text" NOT NULL,
    "bic" "text" NOT NULL,
    "taux_horaire" numeric(10,2) DEFAULT 20.00 NOT NULL,
    "devise" "text" DEFAULT 'EUR'::"text" NOT NULL,
    "conditions_paiement" "text" DEFAULT 'Paiement comptant à réception'::"text" NOT NULL,
    "penalites_retard" "text" DEFAULT 'Taux BCE + 10 pts, indemnité forfaitaire 40 €'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "slug" "text",
    "code_postal" "text",
    "ville" "text",
    "pays" "text" DEFAULT 'France'::"text",
    "adresse_ligne2" "text",
    "stripe_account_id" "text"
);


ALTER TABLE "public"."entreprise" OWNER TO "postgres";


ALTER TABLE "public"."entreprise" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."entreprise_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."factures" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "mission_id" bigint,
    "entreprise_id" bigint NOT NULL,
    "numero" "text" NOT NULL,
    "date_emission" "date" DEFAULT CURRENT_DATE NOT NULL,
    "client_name" "text" NOT NULL,
    "client_address_ligne1" "text",
    "contact_name" "text",
    "contact_phone" "text",
    "contact_email" "text",
    "description" "text",
    "rate" numeric(10,2),
    "montant_ht" numeric(10,2) NOT NULL,
    "tva" numeric(5,2) DEFAULT 0,
    "montant_ttc" numeric(10,2) NOT NULL,
    "mention_tva" "text",
    "conditions_paiement" "text",
    "penalites_retard" "text",
    "url" "text",
    "client_code_postal" "text",
    "client_ville" "text",
    "client_pays" "text" DEFAULT 'France'::"text",
    "client_address_ligne2" "text",
    "stripe_session_id" "text",
    "stripe_payment_intent" "text",
    "payment_link" "text",
    "status" "public"."facture_status" DEFAULT 'pending_payment'::"public"."facture_status",
    "hours" numeric,
    CONSTRAINT "factures_rate_check" CHECK (("rate" >= (0)::numeric))
);


ALTER TABLE "public"."factures" OWNER TO "postgres";


ALTER TABLE "public"."factures" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."factures_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."mission_templates" (
    "id" bigint NOT NULL,
    "client_id" "uuid",
    "nom" "text" NOT NULL,
    "etablissement" "text" NOT NULL,
    "etablissement_adresse_ligne1" "text",
    "etablissement_adresse_ligne2" "text",
    "etablissement_code_postal" "text",
    "etablissement_ville" "text",
    "etablissement_pays" "text",
    "contact_name" "text",
    "contact_email" "text",
    "contact_phone" "text",
    "instructions" "text",
    "mode" "text" DEFAULT 'freelance'::"text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."mission_templates" OWNER TO "postgres";


ALTER TABLE "public"."mission_templates" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."mission_templates_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."missions" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "etablissement" "text" NOT NULL,
    "etablissement_adresse_ligne1" "text",
    "contact_name" "text",
    "contact_email" "text" NOT NULL,
    "contact_phone" "text" NOT NULL,
    "instructions" "text",
    "mode" "public"."mission_mode" DEFAULT 'freelance'::"public"."mission_mode" NOT NULL,
    "status" "public"."mission_status" DEFAULT 'proposed'::"public"."mission_status" NOT NULL,
    "devis_url" "text",
    "client_id" "uuid",
    "freelance_id" "uuid",
    "entreprise_id" bigint,
    "etablissement_code_postal" "text",
    "etablissement_ville" "text",
    "etablissement_pays" "text" DEFAULT 'France'::"text",
    "etablissement_adresse_ligne2" "text"
);


ALTER TABLE "public"."missions" OWNER TO "postgres";


ALTER TABLE "public"."missions" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."missions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "role" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "first_name" "text",
    "last_name" "text",
    "phone" "text",
    "email" "text",
    CONSTRAINT "profiles_role_check" CHECK (("role" = ANY (ARRAY['freelance'::"text", 'client'::"text", 'admin'::"text"])))
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."slots" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "start" timestamp with time zone,
    "end" timestamp with time zone,
    "title" "text",
    "entreprise_id" bigint,
    "mission_id" bigint
);


ALTER TABLE "public"."slots" OWNER TO "postgres";


COMMENT ON TABLE "public"."slots" IS 'La table qui contient les differents créneaux où je suis indisponible';



ALTER TABLE "public"."slots" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."slots_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."unavailabilities" (
    "id" bigint NOT NULL,
    "entreprise_id" bigint NOT NULL,
    "title" "text" DEFAULT 'Unavailability'::"text",
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL,
    "recurrence_type" "text" DEFAULT 'weekly'::"text" NOT NULL,
    "start_date" "date" NOT NULL,
    "recurrence_end" "date",
    "weekday" integer,
    "exceptions" "jsonb" DEFAULT '[]'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "unavailabilities_recurrence_type_check" CHECK (("recurrence_type" = ANY (ARRAY['none'::"text", 'daily'::"text", 'weekly'::"text", 'monthly'::"text"]))),
    CONSTRAINT "unavailabilities_time_range" CHECK (("start_time" < "end_time")),
    CONSTRAINT "unavailabilities_weekday_check" CHECK ((("weekday" >= 0) AND ("weekday" <= 6)))
);


ALTER TABLE "public"."unavailabilities" OWNER TO "postgres";


ALTER TABLE "public"."unavailabilities" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."unavailabilities_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entreprise"
    ADD CONSTRAINT "entreprise_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."entreprise"
    ADD CONSTRAINT "entreprise_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."factures"
    ADD CONSTRAINT "factures_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."mission_templates"
    ADD CONSTRAINT "mission_templates_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."missions"
    ADD CONSTRAINT "missions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."slots"
    ADD CONSTRAINT "slots_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."unavailabilities"
    ADD CONSTRAINT "unavailabilities_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "unique_client_entreprise" UNIQUE ("client_id", "entreprise_id");



CREATE UNIQUE INDEX "factures_numero_unique" ON "public"."factures" USING "btree" ("entreprise_id", "numero");



CREATE INDEX "idx_factures_mission_id" ON "public"."factures" USING "btree" ("mission_id");



CREATE INDEX "idx_slots_mission_id" ON "public"."slots" USING "btree" ("mission_id");



CREATE INDEX "idx_unavailabilities_entreprise_id" ON "public"."unavailabilities" USING "btree" ("entreprise_id");



CREATE INDEX "idx_unavailabilities_recurrence_end" ON "public"."unavailabilities" USING "btree" ("recurrence_end");



CREATE INDEX "idx_unavailabilities_start_date" ON "public"."unavailabilities" USING "btree" ("start_date");



CREATE INDEX "idx_unavailabilities_weekday" ON "public"."unavailabilities" USING "btree" ("weekday");



CREATE OR REPLACE TRIGGER "trg_unavailabilities_validate" BEFORE INSERT OR UPDATE ON "public"."unavailabilities" FOR EACH ROW EXECUTE FUNCTION "public"."unavailabilities_validate"();



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."client_contacts"
    ADD CONSTRAINT "client_contacts_entreprise_id_fkey" FOREIGN KEY ("entreprise_id") REFERENCES "public"."entreprise"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."clients"
    ADD CONSTRAINT "clients_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."entreprise"
    ADD CONSTRAINT "entreprise_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."factures"
    ADD CONSTRAINT "factures_entreprise_id_fkey" FOREIGN KEY ("entreprise_id") REFERENCES "public"."entreprise"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."factures"
    ADD CONSTRAINT "factures_mission_id_fkey" FOREIGN KEY ("mission_id") REFERENCES "public"."missions"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."mission_templates"
    ADD CONSTRAINT "mission_templates_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."missions"
    ADD CONSTRAINT "missions_client_id_fkey" FOREIGN KEY ("client_id") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."missions"
    ADD CONSTRAINT "missions_entreprise_id_fkey" FOREIGN KEY ("entreprise_id") REFERENCES "public"."entreprise"("id");



ALTER TABLE ONLY "public"."missions"
    ADD CONSTRAINT "missions_freelance_id_fkey" FOREIGN KEY ("freelance_id") REFERENCES "auth"."users"("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."slots"
    ADD CONSTRAINT "slots_entreprise_id_fkey" FOREIGN KEY ("entreprise_id") REFERENCES "public"."entreprise"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."slots"
    ADD CONSTRAINT "slots_mission_id_fkey" FOREIGN KEY ("mission_id") REFERENCES "public"."missions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."unavailabilities"
    ADD CONSTRAINT "unavailabilities_company_id_fkey" FOREIGN KEY ("entreprise_id") REFERENCES "public"."entreprise"("id") ON DELETE CASCADE;



CREATE POLICY "Anyone can view entreprise" ON "public"."entreprise" FOR SELECT USING (true);



CREATE POLICY "Anyone can view slots" ON "public"."slots" FOR SELECT USING (true);



CREATE POLICY "Client can delete their missions" ON "public"."missions" FOR DELETE USING (("client_id" = "auth"."uid"()));



CREATE POLICY "Client can insert mission" ON "public"."missions" FOR INSERT WITH CHECK (("client_id" = "auth"."uid"()));



CREATE POLICY "Client can manage his templates" ON "public"."mission_templates" USING (("auth"."uid"() = "client_id")) WITH CHECK (("auth"."uid"() = "client_id"));



CREATE POLICY "Client can see their missions" ON "public"."missions" FOR SELECT USING (("client_id" = "auth"."uid"()));



CREATE POLICY "Client can update their missions" ON "public"."missions" FOR UPDATE USING (("client_id" = "auth"."uid"())) WITH CHECK (("client_id" = "auth"."uid"()));



CREATE POLICY "Client can view their missions" ON "public"."missions" FOR SELECT USING (("client_id" = "auth"."uid"()));



CREATE POLICY "Entreprise peut insérer ses factures" ON "public"."factures" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "factures"."entreprise_id") AND ("e"."user_id" = "auth"."uid"())))));



CREATE POLICY "Entreprise peut lire ses factures" ON "public"."factures" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "factures"."entreprise_id") AND ("e"."user_id" = "auth"."uid"())))));



CREATE POLICY "Entreprise peut mettre à jour ses factures" ON "public"."factures" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "factures"."entreprise_id") AND ("e"."user_id" = "auth"."uid"())))));



CREATE POLICY "Entreprise peut supprimer ses factures" ON "public"."factures" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "factures"."entreprise_id") AND ("e"."user_id" = "auth"."uid"())))));



CREATE POLICY "Freelance can manage own entreprise" ON "public"."entreprise" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Freelance can manage slots of own entreprise" ON "public"."slots" USING (("entreprise_id" IN ( SELECT "entreprise"."id"
   FROM "public"."entreprise"
  WHERE ("entreprise"."user_id" = "auth"."uid"()))));



CREATE POLICY "Freelance can manage their own slots" ON "public"."slots" USING (("entreprise_id" IN ( SELECT "entreprise"."id"
   FROM "public"."entreprise"
  WHERE ("entreprise"."user_id" = "auth"."uid"())))) WITH CHECK (("entreprise_id" IN ( SELECT "entreprise"."id"
   FROM "public"."entreprise"
  WHERE ("entreprise"."user_id" = "auth"."uid"()))));



CREATE POLICY "Freelance can see their missions" ON "public"."missions" FOR SELECT USING (("freelance_id" = "auth"."uid"()));



CREATE POLICY "Freelance can update own entreprise" ON "public"."entreprise" FOR UPDATE USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "Freelance can update their missions" ON "public"."missions" FOR UPDATE USING (("freelance_id" = "auth"."uid"())) WITH CHECK (("freelance_id" = "auth"."uid"()));



CREATE POLICY "Freelance can view their missions" ON "public"."missions" FOR SELECT USING (("freelance_id" = "auth"."uid"()));



CREATE POLICY "Users can update their own profile" ON "public"."profiles" FOR UPDATE USING (("auth"."uid"() = "id")) WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "Users can view their own profile" ON "public"."profiles" FOR SELECT USING (("auth"."uid"() = "id"));



ALTER TABLE "public"."entreprise" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "entreprise_admin_all" ON "public"."entreprise" USING ((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text"));



CREATE POLICY "entreprise_owner_update" ON "public"."entreprise" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "entreprise_public_read" ON "public"."entreprise" FOR SELECT USING (true);



ALTER TABLE "public"."factures" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."mission_templates" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."missions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "missions_admin_all" ON "public"."missions" USING ((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text"));



CREATE POLICY "missions_owner_update" ON "public"."missions" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "missions"."entreprise_id") AND ("e"."user_id" = "auth"."uid"())))));



CREATE POLICY "missions_public_insert" ON "public"."missions" FOR INSERT WITH CHECK (true);



CREATE POLICY "missions_public_read" ON "public"."missions" FOR SELECT USING (true);



ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."slots" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "slots_admin_all" ON "public"."slots" USING ((("auth"."jwt"() ->> 'role'::"text") = 'admin'::"text"));



CREATE POLICY "slots_owner_manage" ON "public"."slots" USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "slots"."entreprise_id") AND ("e"."user_id" = "auth"."uid"())))));



CREATE POLICY "slots_public_read" ON "public"."slots" FOR SELECT USING (true);



ALTER TABLE "public"."unavailabilities" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "unavailabilities_delete_owner_or_admin" ON "public"."unavailabilities" FOR DELETE USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "unavailabilities"."entreprise_id") AND (("e"."user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."profiles" "p"
          WHERE (("p"."id" = "auth"."uid"()) AND ("p"."role" = 'admin'::"text")))))))));



CREATE POLICY "unavailabilities_insert_owner_or_admin" ON "public"."unavailabilities" FOR INSERT WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "unavailabilities"."entreprise_id") AND (("e"."user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."profiles" "p"
          WHERE (("p"."id" = "auth"."uid"()) AND ("p"."role" = 'admin'::"text")))))))));



CREATE POLICY "unavailabilities_select_owner_or_admin" ON "public"."unavailabilities" FOR SELECT USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "unavailabilities"."entreprise_id") AND (("e"."user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."profiles" "p"
          WHERE (("p"."id" = "auth"."uid"()) AND ("p"."role" = 'admin'::"text")))))))));



CREATE POLICY "unavailabilities_update_owner_or_admin" ON "public"."unavailabilities" FOR UPDATE USING ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "unavailabilities"."entreprise_id") AND (("e"."user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."profiles" "p"
          WHERE (("p"."id" = "auth"."uid"()) AND ("p"."role" = 'admin'::"text"))))))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."entreprise" "e"
  WHERE (("e"."id" = "unavailabilities"."entreprise_id") AND (("e"."user_id" = "auth"."uid"()) OR (EXISTS ( SELECT 1
           FROM "public"."profiles" "p"
          WHERE (("p"."id" = "auth"."uid"()) AND ("p"."role" = 'admin'::"text")))))))));





ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";

























































































































































GRANT ALL ON FUNCTION "public"."unavailabilities_validate"() TO "anon";
GRANT ALL ON FUNCTION "public"."unavailabilities_validate"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."unavailabilities_validate"() TO "service_role";


















GRANT ALL ON TABLE "public"."client_contacts" TO "anon";
GRANT ALL ON TABLE "public"."client_contacts" TO "authenticated";
GRANT ALL ON TABLE "public"."client_contacts" TO "service_role";



GRANT ALL ON SEQUENCE "public"."client_contacts_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."client_contacts_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."client_contacts_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."clients" TO "anon";
GRANT ALL ON TABLE "public"."clients" TO "authenticated";
GRANT ALL ON TABLE "public"."clients" TO "service_role";



GRANT ALL ON TABLE "public"."entreprise" TO "anon";
GRANT ALL ON TABLE "public"."entreprise" TO "authenticated";
GRANT ALL ON TABLE "public"."entreprise" TO "service_role";



GRANT ALL ON SEQUENCE "public"."entreprise_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."entreprise_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."entreprise_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."factures" TO "anon";
GRANT ALL ON TABLE "public"."factures" TO "authenticated";
GRANT ALL ON TABLE "public"."factures" TO "service_role";



GRANT ALL ON SEQUENCE "public"."factures_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."factures_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."factures_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."mission_templates" TO "anon";
GRANT ALL ON TABLE "public"."mission_templates" TO "authenticated";
GRANT ALL ON TABLE "public"."mission_templates" TO "service_role";



GRANT ALL ON SEQUENCE "public"."mission_templates_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."mission_templates_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."mission_templates_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."missions" TO "anon";
GRANT ALL ON TABLE "public"."missions" TO "authenticated";
GRANT ALL ON TABLE "public"."missions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."missions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."missions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."missions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "anon";
GRANT ALL ON TABLE "public"."profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."profiles" TO "service_role";



GRANT ALL ON TABLE "public"."slots" TO "anon";
GRANT ALL ON TABLE "public"."slots" TO "authenticated";
GRANT ALL ON TABLE "public"."slots" TO "service_role";



GRANT ALL ON SEQUENCE "public"."slots_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."slots_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."slots_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."unavailabilities" TO "anon";
GRANT ALL ON TABLE "public"."unavailabilities" TO "authenticated";
GRANT ALL ON TABLE "public"."unavailabilities" TO "service_role";



GRANT ALL ON SEQUENCE "public"."unavailabilities_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."unavailabilities_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."unavailabilities_id_seq" TO "service_role";









ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";






























RESET ALL;
